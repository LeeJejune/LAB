> **연산자**(operator): 연산은 수행하는 기호(+, -, *, / 등)                                                                          **피연산자**(operand): 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
>

## 연산자의 우선순위


헷갈리는 &&와 ||의 우선순위

```java
x < -1 || x > 3 && x < 5

// 논리 연산자 중에서 AND는 OR 보다 우선순위가 높다 이처럼 수식에 AND와 OR를 함께
// 사용되는 경우에는 괄호를 사용해 우선순위를 명확히 하는것이 좋다!
```

나름대로 연산자의 결합규칙이 있다. 두가지 경우가 있다.

1. 왼쪽에서 오른쪽 → 단항 연산자와 대입 연산자 제외 모든것
2. 오른쪽에서 왼쪽 → 단항 연산자 대입 연산자.

## 산술 변환

```java
int i = 10;
float f = 20.0f;
float result = f + t; // 큰 타입으로 형변환시, 형변환 연산자 생략가능

// 대부분에 경우 큰 타입으로 일치시켜야 한다. 그 이유는 작은 타입으로 형변환하면
// 원래의 값이 손실될 가능성이 있기 때문!
```

**!** 여기서 주의 점. → byte나 char 같이 int형보다 작은 타입이면 계산할 때 int형으로 변환된다.

이유는 값손실을 최소하하기 위함이고, int가 가장 효율적으로 처리 될 수 있는 타입이기 때문이다. 그리고 int보다 작은 타입, char나 short의 표현범위가 좁아 연산중 오버플로우(overflow) 발생 가능성이 높다.

## 전위 후위 연산자

```java
j = ++i;
-> ++i;
-> j = i;

----------

j = i++;
-> j = i;
-> i++;
```

주의 점! 증감연산자를 사용하면 코드가 간결해지지만, 너무 많이 사용하면 복잡해진다.

ex) x = x++ - ++x; → 벌써 어지럽다.

하나의 식에서 증감연산자의 사용을 최소화하고, 식에 두번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야한다.

## 사칙연산자

```java
public static void main(String[] args){
		byte a = 10;
		byte b= 30;
		byte c = a + b; // 에러 -> a + b 는 int형이기 때문에 형변환 해줘야함.
		System.out.println(c);
}

----------------------------------------
public static void main(String[] args){
		byte a = 10;
		byte b= 30;
		byte c = byte(a) * byte(b); 
		System.out.println(c); // 출력은 44. 이유는?! byte로 바꿔서 값 손실이 난 것이다.
}

----------------------------------------
public static void main(String[] args){
		int a = 1_000_000;
		int b= 2_000_000;
		longc = a * b;
		System.out.println(c); // 출력은 -1454759936 int형 계산이라 오버플로우 남. 
		// 이를 해결하려면 a * b에서 하나한테 long을 부여하면 됨.
}

----------------------------------------
public static void main(String[] args){
		int a = 1000000;
		int result1 = a * a / a;
		int result2 = a / a * a;
		System.out.println(result1); // -727
		System.out.println(result2); // 1000000

		// 이유는 result1은 곱하기를 먼저 해서 오버플로우 발생
		// 연산자의 순서로 인해 값이 완전히 달라짐.
}

----------------------------------------
public static void main(String[] args){
		char a = 'a';

		char c2 = c1 + 1; // 컴파일 에러. 형변호나 없어서.
		char c2 = 'a' + 1; // 컴파일 에러아님.

		System.out.println(c2); 
		// 상수나 리털럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에 컴파일러가 처리.
}

```

## 논리부정연산자

! 사용을 열심히하자.

```java
ex)
ch < 'a' || ch > 'z' -> !('a' <= ch && ch <= 'z')
// 논리식은 알아보기 쉽게 사용해야한다.
// 개발할 때도 주로 논리부정연산자(!)를 많이 사용하는데... 
// 생각보다 그냥 !로 쓰면 편한걸 논리식을 막 쓰는 경우가 있다
// 꿍'S 한마디 !를 적절히 사용해서 표현하자.
```

## 조건 연산자

흔히 삼항 연산자라고 많이 부르는 것!

```java
( x > y ) ? 1 : 0
// x > y가 참이면 1 거짓이면 0
// 위와 같이 삼항 연산자를 활용한다면 if문보다 좋은 케이스를 만들기 쉽다.

ex)
result = (x > y) ? x : y;
// 위를 if 로 바꾼다면
if ( x > y){
	result = x;
} else {
	result = y;
}

// 실제 개발에서도 상당히 많이 쓰임 ㅇ.ㅇ
// 이또한 식에 한번 정도 하는 것이 좋다. 여러번 쓰면 어질어질해
```