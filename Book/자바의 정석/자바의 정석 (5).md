> **객체지향이란? 객체들이 서로 메시지를 통해 협력하는 패러다임**
>

### 객체지향의 특징

1. 코드의 재사용이 높다
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

→ 코드의 재사용성이 높고 유지보수가 좋다! 하지만 처음부터 너무 객체지향에 얽매이지 말고 천천히 객체지향적으로 코드를 개선해 나가는 것이 좋다.

### 클래스와 객체

**클래스란?**

- 객체를 정의 해놓은 것 or 객체를 설계하는 틀
- 객체를 생성할 때 사용된다.

**객체란?**

- 실제로 존재하는 것. 사물 또는 개념
- 객체의 기능과 속성의 따라 용도가 달라짐

클래스로부터 객체를 만드는 과정을 **인스턴스화**라고 한며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스**라고 한다!

→ **클래스 → 인스턴스화 → 인스턴스(객체)**

### 객체의 구성요소

> **속성(property):** 멤버변수, 특성, 필드, 상태                                                                                              **기능(function):** 메서드, 함수, 행위
>

ex) → TV라는 객체는 크기, 길이, 높이, 볼륨 등의 속성을 가지고 켜기, 끄기, 볼륨 조절이라는 기능을 가진다.

### 인스턴스의 생성과 사용

```java
클래스명 변수명;
변수명 = new 변수명();

Tv t;
t = new Tv(); 

-> **인스턴스를 다루기 위해선 참조변수가 꼭 필요함.**
-> **또한 참조변수는 하나의 값(주소)만 저장가능, 둘 이상의 값을 가르키는 것은 안됨.**

// 위 TV 예제를 본다면
Class Tv{
	String color;
	boolean power;
	int channel;

	void power() { power = !power; }
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}
//Tv 클래스 작성 완료 -> TV클래스를 생성하면 그 인스턴스는 Tv의 속성과 기능들을 가지고 있음!
//이런 Tv 클래스는 Ox100이라는 주소공간에 속성부터 기능까지 쭈주죽 들어가있다.
```

```java
Tv[] tvArr = new Tv[3];
-> 객체를 다루기 위한 참조 변수들을 만든 것 뿐이지, 아직 객체가 저장되지 않음.

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
-> 이처럼 객체를 생성해서 각 배열의 요소에 저장해야 한다.

// 초기화 블럭을 사용한다면?
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

### 변수와 메서드

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bfb815cb-92a3-4574-b5e2-e22c26114697/Untitled.png)

> **인스턴스 변수**: 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 이는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있음.                                                                                                                                      **클래스 변수**: static을 붙여만든 변수이므로 인스턴스 변수마다 독립적인 저장공간을 갖는 인스턴스 변수와는 달리, 클래스변수는 모든 인스턴스가 공통된 저장공간을 공유한다. 클래스 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지됨!                                                      **지역변수**: 메서드나 반복문 또는 조건문 안에 선언된 변수들
>

**메서드**

- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.
- 높은 재사용성
- 중복된 코드의 제거
- 프로그램의 구조화

```java
메서드이 선언

//ex
int add(int x, int y){
	int result = x + t;
	return result;
}
-> 반환타입, 메서드이름, 매개변수 선언 등이 필요!
-> int result = add(3, 5);
-> 위처럼 메서드를 호출했을 때 매개변수에 대입이 되므로
-> 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.
```

### JVM의 메모리 구조

[[JAVA] JVM이란? 개념 및 구조 (JDK, JRE, JIT, 가비지 콜렉터...)](https://doozi0316.tistory.com/entry/1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80)

**JVM의 메모리 영역**

1. Method Area
2. Call stack
3. Heap

**메서드 영역(Method area)**: 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 이를 클래스파일(*.class)을 읽어 분석하여 클래스에대한 정보를 저장한다. 이 때 클래스변수도 함께 생성됨.

**힙 영역(Heap)**: 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성됨.

**호출 스택(call stack)**: 메서드의 작업에 필요한 메모리 공간을 제공, 메서드가 호출되면, 호출스택에 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용됨. 메서드가 작업을 마치면 할당된 메모리 공간을 반환하여 비워짐.

→ 쉽게 생각하면 메서드 호출 시 스택(호출스택)에 하나 씩 쌓이는 것이다! 그리고 메서드가 작업을 마치면 메모리를 반환하고 스택에서 제거됨. 그리고 그 다음 메서드를 실행.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13bafecc-7717-4948-b601-48e0eaa16061/Untitled.png)

### 기본형 매개변수와 참조형 매개변수

```java
class Data { int x; }
public class etc {
    public static void main(String[] args) {
        Data d = new Data();
        d.x = 10;
        System.out.println("main : x =" + d.x);

        change(d.x);
        System.out.println("main : x =" + d.x);
    }

    private static void change(int x) {
        x = 1000;
        System.out.println("change : x =" + x);
    }
}
-------------------------------------------------------
main : x =10
change : x =1000
main : x =10

d.x의 값이 변경 된 것이 아니라 change메서드의 매개변수 x의 값이 변경된 것.
-> 이를 해결하려면?

class Data { int x; }
public class etc {
    public static void main(String[] args) {
        Data d = new Data();
        d.x = 10;
        System.out.println("main : x =" + d.x);

        change(d);
        System.out.println("main : x =" + d.x);
    }

    private static void change(Data d) {
        d.x = 1000;
        System.out.println("change : x =" + d);
    }
}
-> 참조형 매개변수를 사용해서 d.x의 값을 변경한다!
```

### 클래스 메서드와 인스턴스 메서드

**클래스 메서드**: 클래스변수처럼 객체를 생성하지 않고도 ‘클래스이름.메서드이름’으로 호출이 가능하다. 반면에 인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.

**인스턴스 메서드**: 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다. **인스턴스를 생성해야만 호출가능.**

→ 인스턴스와 관련이 없는 메서드는 static 메서드(클래스 메서드)로 선언한다.

1. 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것은 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용가능하다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

### 오버로딩

메서드도 변수랑 마찬가지로 같은 클래스 내에 서로 구별될 수 있어야 한다 → 같은 이름을 가진 메서드가 있더라도 매개변수의 개수나 타입이 다르면 정의가능!!

→ 이처럼 같은 이름의 메서드를 여러개 정의하는 것을 **메서드 오버로딩**이라고 한다.

**오버로딩의 조건**

- 메서드 이름이 같아야 한다.
- 메개변수의 개수 또는 타입이 달라야한다.

```java
int add(int a, int b);
long add(int a, int b);
-> 불가능 리턴타입은 오버로딩에 영향을 주지 않아!!

long add(int a, long b);
long add(long a, int b);
-> 매개변수 타입의 순서가 서로 달라서 가능!
-> 하지만 사용자가 매개변수의 순서를 외우지 않는 이상 오히려 단점이 된다.
```

**오버로딩의 장점**

- 비슷한 동작을 하는 메서드 (매개변수 타입만 다른데 기능은 같은 메서드 등)의 이름 짖기를 어려워 할 필요가 없다.
- 메서드 이름을 절약할 수 있다.

### 가변 인자 메서드

```java
String concatenate(String s1, String s2) { .... }
-> 위와 같이 메서드 매개변수의 개수가 상관 없을 때 사용이 가능하다.

String concatenate(String... str) { ... }
-> 이러첨 가변인자 매개변수를 사용하면 동적으로 지정해줄 수 있다.

-> 하지만.. 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때,
-> 구별 되지 못하는 경우가 발생하기 쉽다.
-> 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.
```

### 생성자

생성자란?

- 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’ 이다.
- 생성자의 이름은 클래스의 이름과 같아야 한다.
- 생성자는 리턴 값이 없다.

→ **연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다!!**

```java
Card c = new Card();
-> 연산자 new에 의해서 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
-> 생성자 Card()가 호출되어 수행된다.
-> 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 참조 변수 c에 저장된다.

// 자바의 경우 한 클래스의 정의된 생성자가 없을 경우 컴파일러가 알아서 생성해준다.
// 하지만 이미 생성자가 있을 경우엔 생성해주지 않는다.
```

```java
Car(String color, String gearType, int door){
	this.color = color;
	this.gearType = gearType;
	this.door = door;
}
-> this는 참조변수로 인스턴스 자신을 가리킨다. 참조변수를 통해 인스턴스의 멤버에 접근 가능
-> 하지만 static메서드에서는 사용 불가.
-> 왜 why? 인스턴스를 생성하지 않고도 호출될 수 있으며, 이 때 인스턴스 존재하지 않을 수 있음
```

인스턴스를 생성할 때 결정해야할 두 가지 사항.

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것 인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

### 변수의 초기화

멤버변수의 초기화 방법

- 명시적 초기화
- 생성자
- 초기화 블럭 - 클래스 초기화 블럭, 인스턴스 초기화 블럭

```java
Car() {
	count++;
	serialNo = count;
	...
}
Car() {
	count++;
	serialNo = count;
	...
	...
}
-> 메서드 중 중복되는 코드가 있다면
{
	count++;
	serialNo = count;
}
-> 위처럼 인스턴스 초기화 블럭으로 대체 가능. (처음 봤음)
```