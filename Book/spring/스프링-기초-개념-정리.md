### **[ Servlet(서블릿)이란? ]**

서블릿이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술입니다. Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환합니다.

### **[ Spring 기초지식(DI, DL, IoC, AOP) ]**

- DI(Dependency Injection): 한 객체에서 다른 객체를 필요로 하여 의존성을 갖게 하는 기술
- IoC(Inversion of Control): 직접 제어야하는 부분에 대한 권한을 프레임워크 등에 넘기는 기술
- AOP(Aspect Oriented Programming): 공통의 관심 사항을 추출하여 원하는 곳에 적용하는 기술

- 스프링 DI 3가지 방법과 장단점

  **필드 주입**

    - @Autowird 사용
    - 단점
        - **SRP 위반 → 너무 많은 의존성을 가짐.**
        - 의존성이 눈에 보이지 않음. → 의존성을 눈으로 확인 하기 위해서는 해당 bean의 구현을 하나 하나 뜯어보면서 의존성을 확인 해야함. → 테스트 상황에서 new로 생성 해줘야됨
        - final 선언 불가. → 새로 할당 할 때 알기 어려움.
        - DI 컨테이너와의 강한 결합

  **세터 주입**

    - @Autowird 사용
    - 단점
        - 이것 역시 final 불가
        - 해당 클래스가 초기화 된 이후에 언제든지 변경 될 수 있음. 이건 상황에 따라서 이점이 없을 수 있다. → 변경 가능성을 열어둠. OCP 위반

  **생성자 주입**

    - 장점
        - final 사용 가능 → 불변성 보장
        - 테스트 용이함
        - 롬복과의 결합이 좋음
        - 순환 참조를 막을 수 있음.

- Spring JPA와 JPA의 차이

  JPA

    - JPA는 관계형 데이터베이스와 자바 객체를 매핑하기 위한 인터페이스(API)를 제공하고 JPA 구현체(Hibernate)는 인터페이스를 구현한 것이다.
    - entitymanager를 직접 호출해서 entity crud 처리

  Spring data JPA

    - Spring Data JPA는 Spring Framework에서 제공하는 모듈 중 하나로, 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와준다. (상속)
    - 개발자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면, Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해준다.
- 객체 지향적 설계 원칙
    - SRP(Single Responsibility Principle) : 단일 책임 원칙 - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
    - OCP(Open-Closed Principle) : 개방-폐쇄 원칙 - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    - LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    - DIP(Dependency Inversion Prinsiple) : 의존 역전 원칙 - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
- 스프링 DI
    - 객체들 간의 의존성을 줄이기 위해 사용되는 스프링의 IOC 컨테이너의 구체적 구현 방식을 말한다.
    - 개발코드 부분에서 객체를 생성하는 것이 아니라, 데이터 주입만 담당하는 별도의 공간에서 객체를 생성하고, 데이터 간의 의존성을 주입해 개발코드에서 가져다 쓰면서 의존성을 줄인다.

  스프링 IOC란?

    - 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해주는 것을 말한다.
    - IOC 컨테이너는 DI를 통해 주입시킨다.
    - 인스턴스의 생성의 제어를 bean을 통해 관리해주는 컨테이너가 관리합니다.
    - bean이란 컨테이너가 관리하는 객체.
- DTO VO 차이

  DTO와 VO 차이점

    - VO는 DTO와 동일한 개념이지만 read only 속성을 갖는다. VO는 특정한 비즈니스 값을 담는 객체이고, DTO는 Layer간의 통신 용도로 오고가는 객체를 말한다.
- MVC 패턴
    - MVC 패턴은 Model, View, Controller 이 3가지로 나뉘어 역할을 분할하여 처리한다.
    - 역할을 나누어 처리하기 때문에 서로의 결합도가 낮아져서 좋은 코드가 되며 유지보수도 하기 편해진다.
- DTO를 사용하는 이유
    - 순환참조를 예방할 수 있다.
        - JPA로 개발할 때, 양방향 참조를 사용했다면 순환참조를 조심해야한다.
    - 엔티티 내부 구현을 캡슐화 할 수 있다.
    - DB Layer와 View Layer 사이의 역할을 분리 하기 위해서다
- JPA에서 Entity를 설계할때 주의점
    - Entity에는 가급적 Setter를 사용하지 말 것
        - Entity가 영속성이 유지되는 도중 수정되면 그 값은 DB에 그대로 반영됩니다. 그런데 Setter를 열어두고 값을 변경하는 경우에는 변경 포인트가 많아 유지보수가 어려워 질 수 있습니다.
    - 모든 연관관계는 지연로딩으로 설정한다
        - 즉시로딩(EAGER)를 사용 할 경우, 어떤 SQL이 나갈지 추적하기 어렵다
    - 컬렉션은 필드에서 바로 초기화하자
    - Entity는 최대한 순수하게 유지해야한다!!!
- N+1 문제
    - Lazy 로딩에 의해서 한번에 모든 정보를 안가져와서 발생하는 문제인데 폐치조인을 사용해서 해결할 수 있다.
    - SQL 1번으로 100명의 회원을 조회하였는데,한번 SQL을 실행해서 조회된 결과 수만큼 N번 SQL을 추가로 실행한다고 해서 N+1 문제라 한다.
- 스프링 MVC

  MVC 진행 방식

    - 클라이언트로부터 요청이 들어오면 dispatcherServlet이 가장 먼저받는다.
    - HandlerMapping이 요청 URL과 매핑되는 Controller 검색 후 리턴
    - HandlerAdapter에서 알맞은 controller 처리요청
    - ViewResolver에서 controller가 리턴한 view 검색후 view를 클라이언트로 보냄


- 동기 VS 비동기식

  동기식 - 요청과 결과가 동시에 이루어지는 것. 설계가 간단하지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하므로 비동기식 보다 비효율적이다.

  비동기식 - 요청과 결과가 동시에 이루어지지 않는 것. 하나의 요청을 처리하는 동안 다른 요청도 처리가능. 동기보다 복잡하고 결과가 주어지는데 시간이 걸리더라도 그동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있음.

- GET POST 차이
    - 사용목적 : GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다.DB로 따지면 GET은 SELECT 에 가깝고, POST는 Create 에 가깝다고 보면 된다.
    - GET 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다. POST 는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재한다.
    - GET 요청은 멱등이며, POST는 멱등이 아니다.
    - GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것 이다. 반대로 POST는 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있다.

### **[ Spring WebFlux란? ]**

Spring WebFlux란 Blocking+동기 방식으로 동작하는 Spring MVC의 한계점을 극복하기 위해 Spring5에 처음 등장하게 되었습니다. 기존의 Spring MVC에서는 HTTP 요청들을 큐에 넣어두고, 멀티쓰레드를 기반으로 동작하고 있습니다. 하지만 이러한 방식은 응답성이 상대적으로 떨어지기 때문에 비동기적으로 요청을 처리하기 위한 방법이 필요하게 되었고, 리액티브 프로그래밍을 통해 비동기 데이터 스트림으로 Non-Blocking 애플리케이션을 개발하기 위한 Spring WebFlux 프레임워크가 등장하게 되었습니다.

JPA 장점, 단점

- JPA란 자바 ORM 기술에 대한 API 표준 명세를 의미한다.
- Hibernate는 JPA라는 명세의 구현체이다.
- 장점
    - 생산성 : SQL의 반복작업이 없어진다.
    - 유지보수 : 테이블 컬럼 한개가 바뀌면 Mybatis에서는 관련 DAO의 파라미터, 결과 SQL등을 모두 확인하여 수정해주어야한다. JPA는 대신 해준다.
- 단점
    - 성능 : 직접 SQL을 호출 하는 것보다 성능이 떨어 질 수 있다.
    - 세밀함 : 복잡한 통계 분석 쿼리를 메서드 호출로 처리하기 힘들다. (이러한 문제를 보완하기 위해 JPA에서 JPQL을 지원한다

### **⌨️ 즉시 로딩(Eager Loading)과 지연 로딩(Lazy Loading)의 장단점**

**즉시 로딩(Earge Loading) 장점**

- 지연된 초기화와 관련해서 성능적인 영향이 없음

**즉시 로딩(Earge Loading) 단점**

- 지연 로딩보다 긴 초기의 로딩 시간이 필요함
- 불필요한 데이터를 많이 로딩하면 성능에 영향을 줄 수 있음

**지연 로딩(Lazy Loading) 장점**

- 다른 접근 방식보다 훨씬 적은 초기의 로딩 시간
- 다른 접근 방식에 비해 메모리 소비량 감소

**지연 로딩(Lazy Loading) 단점**

- 초기화가 지연되면 원하지 않는 순간 성능에 영향을 줄 수 있음