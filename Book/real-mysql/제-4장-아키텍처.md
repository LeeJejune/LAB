> 이번주 차 회고. mysql 어렵다. 이놈 쉽지 않은 놈이다.
>

## 4.1 MySQL 엔진 아키텍처

MySQL 서버 는 **사람의 머리 역할**을 담당하는 MySQL **엔진**관 **손발 역할**을 담당하는 **스토리지 엔진**으로 구분 가능!

(아래 사진은 MySQL의 쿼리 파서나 옵티마이저 등과 같은 기능을 스토리지 엔진과 구분하기 위해!)

![img.png](img.png)

쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다!

### 🤔 스토리지 엔진이 뭐야 대체..

MySQL 엔진이 요청된 SQL 문장을 분석 및 최적화를 하는 두뇌라면 실제 데이터를 **디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 담당하는게 스토리지 엔진**!!!

### 그러면 스토리지 엔진에 어떻게 요청하지?!

쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 스토리지 엔진에 요청을 하는데 이러한 요청을 **핸들러(Handler) 요청**이라 한다.

→ SHOW GLOBAL STATUS LIKE ‘Handler%” 라고 하면 확인 가능

## 스레딩 구조

> MySQL 서버는 프로세스 기반이 아닌 스레드 기반! 크게 포그라운드, 백그라운드로 나뉜다.
>

![img_1.png](img_1.png)

### 그럼 포그라운드가 뭔데?

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리하는 것!

→ InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 것은 백그라운드가 한다.

### 백그라운드 스레드!

가장 중요한 것은 **로그 스레드**와 버퍼의 데이터를 **디스크로 내려쓰는 작업을 처리하는 쓰기 쓰레드!**

일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재돼 있으며, InnoDB 또한 이러한 방식을 사용한다! 그래서 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 파일로 완전히 저장 될 때까지 기다릴 필요가 없다!

## 메모리 할당 및 사용 구조

![img_2.png](img_2.png)

MySQL은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분!

### 글로벌 메모리 영역..? 흠..

- MySQL 서버를 실행할 때 운영체제로부터 설정한 만큼 할당받는 영역
- 모든 스레드로부터 공유되는 영역

→ InnoDB 버퍼 풀, 테이블 캐시 등등..

### 로컬 메모리 영역

- 세션 메모리 영역
- 쿼리를 처리하는데 사용되는 영역
- 스레드 별로 독립적이라 절대 공유되지 않는 영역
- 쿼리의 용도 별로 할당이 될 때도 있고 아예 할당되지 않을 때도 있음

→ 정렬 버퍼, 조인 버퍼 등..

## 쿼리 실행 과정

SQL 파서 → SQL 옵티마이저 → SQL 실행기 ↔ 데이터 읽기/쓰기 ↔ 디스크

(파란색은 MySQL 엔진, 초록색은 스토리지 엔진)

**즉, SQL로 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어 오거나 저장하도록 명령하려면 핸들러를 반드시 통해야한다! 여기서의 핵심은 하위 작업들이 어디에서 처리되는지!!**

![img_3.png](img_3.png)

### 쿼리파서

쿼리 문장을 토큰(MySQL이 인식할 수 있는 어휘)로 분리해 트리 형태의 구조로 만들어 내는 작업

### 전처리기

파서 과정에서의 문제점을 확인하는 작업.

### 옵티마이저

사실상 DBMS의 두뇌. 가장 저렴한 비용으로 빠르게 처리할지 결정하는 담당.

## 실행 엔진

결국 스토리지 엔진을 의미하는 것이 핸들러이다. **MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 디스크로 저장하고 디스크로부터 읽어오는 역할을 하기 때문!**

## InnoDB 스토리지 엔진 아키텍처

![img_4.png](img_4.png)

### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. **즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻**이며, 이로 인해 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다. 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정(쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음)된다.

**외래 키 지원**

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨이서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다. 외래 키는 여러 가지 제약사항 탓에 실무에서는 잘 사용하지 않기 때문에 그렇게 필수적이지는 않지만 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.

⇒ InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.

**MVCC(Multi Version Concurrency Control)**

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 지원하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB는 언두 로그를 이용해 이 기능을 구현한다. 여기서 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다.

```sql
mysql > CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);

mysql > INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
mysql > COMMIT;

//INSERT 문이 실행되면, 데이터베이스의 상태는 아래 그림과 같은 상태로 바뀔 것이다.
```
![img_5.png](img_5.png)

```sql
mysql > UPDATE member SET m_area='경기' WHERE m_id=12;
```

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이, InnoDB의 버퍼 풀은 새로운 값인 "경기"로 업데이트된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다(InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다).

그럼 조회라면?!

MySQL 초기화 파라미터에 설정된 **격리 수준(Isolation level)에 따라 다르다.** **만약 격리 수준이 READ_UNCOMMITTED인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환**한다. 즉, **데이터가 커밋됐든 아니든 변경된 상태의 데이터를 반환**한다. 그렇지 않고 READ_COMMITTED나 **그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환**한다.

**잠금 없는 일관된 읽기(Non-locking consistent read)**

READ-COMMITTED 그리고 REPEATABLE-READ 수준인 경우 INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

> 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다.
>

![img_6.png](img_6.png)

****자동화된 장애 복구****

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 기능이 탑재되어있다. 이를 통해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

**자동 데드락 감지**

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기목록을 그래프(Wait-for-List) 형태로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다.

⇒ 이때 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다

⇒ 롤백을 해도 언두 처리를 해야할 내용이 적다는 것이며, 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.

## Inno DB 버퍼풀

Inno DB에서 가장 핵심적인 부분

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.

쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.

⇒ 일반적인 iNSERT, UPDATE, DELETE처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킴.

버퍼 풀의 크기는 적절히 작은 값으로 설정해서 조금씩 상황을 봐가면서 증가 시키는게 최적.

**버퍼 풀의 구조**

거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어 각 조각에 저장한다.

3개의 자료구조 사용

- 프리 리스트
    - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않는 비어있는 페이지들의 목록
- LRU 리스트 (Least Recently Used) LRU와 MRU(Most Recently Used)
    - 리스트가 결합된 형태 LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다. 자주 사용된다면 MRU 영역에 살아남고, 거의 사용되지 않는다면 LRU 끝으로 밀려나 버퍼 풀에서 제거된다.
        - LRU(Least Recently Used)는 가장 오래 전에 마지막으로 사용했던 페이지를 버퍼에서 내보내는 알고리즘입니다.
        - MRU(Most Recently Used)는 가장 최근에 연산이 끝난 블록을 버퍼에서 버리는 알고리즘입니다.
- 플러시 리스트
    - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리한다. 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화한다.


**버퍼 풀과 리두 로그**

InnoDB 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할수록 쿼리 성능이 빨라진다. InnoDB 버퍼 풀은 데이터베이스 서버 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두가지 용도가 있는데, 버퍼 풀의 메모리 공간만 늘리는 것은 데이터 캐시 기능만 향상시킨다.

⇒ 쓰기 버퍼링..?

⇒ InnoDB 버퍼 풀은 클린 페이지와 더티 페이지를 갖는다. 더티 페이지는 언젠가 디스크로 기록되어야 한다.

데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 새로운 로그 엔트리로 덮어 쓰인다. 그래서 InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간, 불가능한 공간을 구분해서 관리해야 하는데, 재사용 불가능한 공간이 활성 리두 로그다.

**버퍼 풀 플러시**

InnoDB 스토리지 엔진은 버퍼 풀에서 더티 페이지들을 성능 저하 없이 디스크에 동기화하기 위해 플러시 리스트 플러시, LRU 리스트 플러시를 백그라운드에서 실행한다.

- 플러시 리스트 플러시
    - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야 한다. 리두 로그 공간이 지워지려면 InnoDB 버퍼 풀의 더티 페이지가 디스크로 동기화되어야 한다. 이를 위해 주기적으로 플러시 리스트 플러시 함수를 호출한다.
- LRU 리스트 플러시
    - LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하고, 이때 LRU 리스트 플러시 함수가 사용된다.

**버퍼 풀 상태 백업 및 복구**

버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로, 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있다. 디스크의 데이터가 버퍼 풀에 적재되어있는 상태를 워밍업이라 한다.

⇒ 속도가 빨라요.

MySQL은 버퍼 풀 덤프, 적재 기능을 제공한다. 서버를 종료하기 전에 백업하고, 서버를 재시작한 후 백업된 버퍼 풀의 상태를 복구할 수 있다.

버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문에 백업 파일의 크기는 작고, 백업은 빠르게 완료된다. 하지만 백업된 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정은 해당 내용을 디스크에서 읽어와야 하므로 시간이 걸린다.

**버퍼 풀의 적재 내용 확인**

information_schema 데이터 베이스에 innodb_cached_indexed 테이블을 이용하면, 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다.