## 배열 (Array)

배열은 가장 기본적인 데이터 구조다. 배열은 인덱스(Index)와 인덱스에 해당하는 요소(Element)로 구성된다.

### 특징

1. 길이가 고정되어 생성된다. (정적 메모리 할당)
2. 인덱스를 통해서 각 요소에 직접 접근할 수 있는 특징이 있다.
3. 배열은 논리적 순서와 물리적 순서가 일치한다. 인접한 메모리 위치에 연이어 저장된다.

### **시간 복잡도**

1. **검색 (Search)** : 요소마다 인덱스를 부여했기 때문에, 특정 요소를 접근하는 시간 복잡도는 O(1)이다. 하지만, 인덱스를 모르는 특정 값을 찾기 위해서는 배열의 모든 요소들을 살펴봐야 하기 때문에 O(n)의 시간 복잡도를 갖는다.
2. **추가/삭제 (Insert/Delete)** : 삽입이나 삭제를 하기 위해서는 길이가 고정되어 있기 때문에 차례대로 한 칸씩 밀어야 하는 과정이 필요하고 그 과정에서 O(n)의 시간 복잡도가 생긴다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/87d34a29-90c7-4ade-b6c2-54ac536de498/Untitled.png)

## 연결 리스트 (Linked List)

배열의 추가/삭제 연산에 대한 비효율성을 극복하고자 등장한 데이터 구조이다. 각 요소는 다음 노드 연결에 대한 정보를 담은 포인터 또는 주소와 함께 노드에 저장된다. 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트 등의 종류가 있다.

### **특징**

1. 새로운 요소가 추가될 때 런타임에 메모리를 할당한다. (동적 메모리 할당)
2. 요소에 접근할 때 순차적으로 접근해야 하는 특징이 있다.
3. 인덱스나 위치와 같은 물리적 배치를 사용하지 않고 참조 시스템(다음 노드 연결에 대한 포인터 또는 주소)을 사용한다.

### **시간 복잡도**

1. **검색 (Search)** : 처음부터 순차적으로 접근해야 하기 때문에 O(n)의 시간 복잡도를 갖는다.
2. **추가/삭제 (Insert/Delete)** : 동적인 메모리 크기를 갖기 때문에, 새로운 요소를 추가하거나 삭제할 경우에 해당되는 부분만 변경하면 되기 때문에 O(1)의 시간 복잡도를 갖는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4772008f-d893-4228-b81c-c9938da09a27/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a7d63e1-0529-46f2-ba2c-dd3d881c0537/Untitled.png)

## 스택 (Stack)

순서가 보존되는 선형 자료구조의 일종으로, LIFO(Last In First Out) 메커니즘을 갖고 있다.

### **특징**

1. 데이터를 받는 순서대로 정렬한다.
2. LIFO, 마지막으로 입력된 것을 순차적으로 가져오는 방법을 갖고 있는 것이 특징이다. (FILO도 동일한 의미다)
3. 동적 메모리

### **시간 복잡도**

1. **검색 (Search)** : 처음부터 순차적으로 접근해야 하기 때문에 O(n)의 시간 복잡도를 갖는다.
2. **추가/삭제 (Insert/Delete)** : 가장 위에 데이터를 추가하거나 삭제하기 때문에 O(1)의 시간 복잡도를 갖는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f15b6c76-c428-40a6-8e96-313c9fd9c02f/Untitled.png)

## 큐 (Queue)

순서가 보존되는 선형 자료구조의 일종으로, FIFO(First In First Out) 메커니즘을 갖고 있다.

### **특징**

1. 데이터를 받는 순서대로 정렬한다.
2. FIFO, 가장 먼저 입력된 것을 순차적으로 가져오는 방법을 갖고 있는 것이 특징이다.
3. 동적 메모리

### **시간 복잡도**

1. **검색 (Search)** : 처음부터 순차적으로 접근해야 하기 때문에 O(n)의 시간 복잡도를 갖는다.
2. **추가/삭제 (Insert/Delete)** : 가장 위에 데이터를 추가하거나 삭제하기 때문에 O(1)의 시간 복잡도를 갖는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/badd6982-6a2f-4e1d-9634-6a378533630b/Untitled.png)

## 해쉬 테이블 (Hash Table)

해시 테이블은 키(Key)와 값(Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 검색이 필요할 때 용이하다. 해시 테이블을 구현하기 위해서는 연결 리스트와 해시 함수(Hash Function)가 필요하다. 해싱(Hashing)은 해시 함수를 통해서 임의의 값을 고정된 크기의 값으로 변환하는 작업을 말하는데, 키 값을 입력받아서 해시 함수를 통해 얻은 해시(Hash)를 배열의 인덱스로 환산해서 값에 접근하는 것을 의미한다.

### **특징**

1. 키 값을 배열의 인덱스로 사용하기 때문에, 값을 직접 접근할 수 있다. 따라서, 해시 테이블의 평균 시간 복잡도는 O(1)이다. (운이 없어, 충돌(Collision)이 일어나는 경우 O(n))
2. 충돌이 발생할 수 있다. 이 경우 분리 연결법(Separate Chainging) 혹은 개방 주소법(Open Address)을 사용하여 해결한다.
3. 데이터가 저장되기 이전에 미리 공간을 만들어야한다. 공간 복잡도가 크다.
4. 해시 함수를 통해서 배열 인덱스의 범위를 조절할 수 있다. 이를 리사이징(Resizing)이라고 한다.
5. 키와 해시의 연관성이 없어 보안에도 자주 사용된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d2a348c-5d27-42b6-a997-1bbac06cd411/Untitled.png)

## 그래프 (Graph)

그래프는 비선형 자료구조로, 노드(Node)/정점(Vertice)과 이들 사이를 연결하는 엣지(Edge)로 구성된 자료구조를 의미한다.

### **특징**

1. 그래프는 방향이 있을 수도(Directed) 없을 수도(Undirected) 있다.
2. 다양한 구조로 설계된다. 구조에 따라서 시간 복잡도가 달라지고 다양하게 응용이 가능하다.
3. 새로운 요소들의 추가/삭제가 용이하고 효율적이다.
4. 시간 복잡도/공간 복잡도를 이야기할때 노드(N)/정점(V)과 엣지(E)의 수를 사용하여 표현한다.

### **시간 복잡도**

1. **두 노드의 연결 확인 :** 인접 행렬의 경우 고유 인덱스로 바로 접근 가능하여 O(1)의 시간 복잡도를 갖는다. 인접 리스트의 경우 한 노드의 인접 리스트 안의 특정 노드가 있는지 확인해야 하기 때문에, 최악의 경우 전체를 봐야하므로 O(N)/O(V)의 시간 복잡도를 갖는다.
2. **한 노드에 연결된 모든 노드 확인 :** 인접 행렬의 경우 특정 노드를 나타내는 행렬을 돌아서 연결된 노드를 가져와야 하기 때문에, O(N)/O(V)의 시간 복잡도를 갖는다. 인접 리스트의 경우 연결된 노드의 갯수는 곧 엣지의 갯수이므로, 엣지의 갯수만 확인하면 되므로 O(E)의 시간 복잡도를 갖는다.
3. **추가/삭제 (Insert/Delete)** : 추가의 경우 노드/정점이나 엣지 모두 O(1)의 시간 복잡도를 갖는다. 하지만, 삭제의 경우에는 노드/정점의 경우 특정 노드/정점을 찾는 시간과 그와 연결된 엣지를 삭제해야 하므로 O(N+E)/O(V+E)의 시간 복잡도를 갖는다. 엣지의 경우 특정 엣지를 찾는 시간이 소요되므로 O(E)의 시간 복잡드를 갖는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/afb99282-e6cf-4453-8cb6-844409aa933a/Untitled.png)

## 트리 (Tree)

트리는 비선형 자료구조로, 노드로 구성된 계층적 자료구조이다. 최상위 노드(Root)를 만들고, 부모(Parent) 노드에 자식(Child) 노드를 추가하고 그리고 그 자식 노드가 부모 노드로써 또 다른 자식 노드를 추가하는 구조를 가지고 있다.

### **특징**

1. 트리에 또 다른 트리가 있는 재귀적 자료구조이다.
2. 데이터를 순차적으로 저장하지 않는, 비선형 자료구조이다.
3. 이진트리(Binary Tree), 이진탐색트리(BST, Binary Search Tree), 균형트리(B-Tree, Balanced Tree), 힙트리(Heap Tree) 등 다양한 종류가 존재한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/818685cf-f3e4-4e0b-8e88-9f8af5c63913/Untitled.png)